# MD5（Message-Digest Algorithm 5）

## 概念

### 本质

> MD5是一串散列值，本质上是一个散列函数，而非加密算法。

### 不可逆

> 数据转化为MD5值时，进行了若干次 `与` 、 `或` 、 `非` 、 `循环移位` 的操作，损失了很多数据，这就是为什么MD5加密不可逆

### 碰撞

> 原理上我们可以将任何数据（∞）转化为MD5值，而MD5值的长度固定为128bit，则其取值范围为 `[0, 2^128-1]`，所以一定会有若干个数据的MD5值是相同的，这种情况称之为碰撞



## 生成散列值三步

### 填充对齐

数据以二进制的形式存储在计算机中，MD5算法需要先将数据 `补齐` 为能装下原始数据的512bit的 `最小整数倍` 

假设现有715bit的二进制数据，我们需要在其后补上309bit，将其 `补齐` 为512bit的两倍，其中最后64bit用来存储原始数据的大小，剩余的 309bit - 64bit = 245bit 以1开头，其余为0

- 如果原始数据与 `最小整数倍` 的差不足64bit，则我们应该补上 `最小整数倍` + `1` 倍，以满足假设中的条件



### 分块

> MD5输出值被规定为四块，初始值为下列四个固定的幻数
>
>  `0x67452301`  `0xefcdab89`  `0x98badcfe`  `0x10325476` 

由于我们已经将原始的715bit数据补齐为512bit的整数倍，即1024bit，所以我们一定能将其分割为两个512bit的数据块



### 多轮压缩

我们先用 `a` 、 `b` 、 `c` 、 `d` 分别表示初始值的四个幻数，即

 `a` ： `0x67452301` 、 `b` ： `0xefcdab89` 、 `c` ： `0x98badcfe` 、 `d` ： `0x10325476` 

再进行四轮，每轮四次压缩操作，每次的操作为用第一块数据分别与 `a` 、 `b` 、 `c` 、 `d` 进行一系列的 `与` 、 `或` 、 `非` 、 `循环移位` 的操作，得到新的 `a` 、 `b` 、 `c` 、 `d` 值

目前 `a` 、 `b` 、 `c` 、 `d` 已经被更新了16次，我们再将最后得到的 `a` 、 `b` 、 `c` 、 `d` 值与它们对应的初始值相加，就得到第一块数据的散列值，这个散列值就是第二块数据进行多轮压缩的初始值

直到所有数据块都进行了多轮压缩后，得到的结果就是最终的MD5散列值



至此，MD5加密就完成了